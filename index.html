<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å¤šå€‹å®šæ™‚é¬§é˜</title>
  <style>
    /* ç‰ˆé¢èˆ‡é…è‰² */
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, 'Noto Sans TC', 'PingFang TC', 'Microsoft JhengHei', Arial, sans-serif;
      background: #0b0f14;
      color: #e7eef7;
      margin: 0;
    }

    .container {
      width: min(1100px, 92vw);
      margin: 20px auto;
      background: #0f1620;
      border: 1px solid #1f2a36;
      border-radius: 16px;
      padding: 16px 20px;
      box-shadow: 0 6px 30px rgba(0, 0, 0, 0.35);
    }

    .topbar h1 {
      margin: 0 0 10px 0;
      font-size: 22px;
      letter-spacing: 1px;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .row.gap {
      gap: 10px;
    }

    .hint {
      color: #92a3b5;
    }

    /* é¬§é˜æ¸…å–®ï¼ˆç”±å·¦è‡³å³ä¸¦æ’ï¼‰ */
    .alarms-container {
      width: min(1200px, 96vw);
      margin: 10px auto 40px auto;
      display: flex;
      flex-wrap: wrap;
      gap: 14px;
      align-items: stretch;
      justify-content: flex-start;
    }

    @keyframes alarm-blink {
      0% {
        background-color: #0f1620;
        border-color: #1f2a36;
      }

      50% {
        /* ç¨å¾®æé«˜äº®åº¦ï¼Œè®“é–ƒçˆæ›´æ˜é¡¯ */
        background-color: #1a2635;
        border-color: #5aa3ff;
        box-shadow: 0 0 15px rgba(90, 163, 255, 0.6);
      }

      100% {
        background-color: #0f1620;
        border-color: #1f2a36;
      }
    }

    .alarm-card.is-blinking {
      animation: alarm-blink 0.5s infinite;
      /* æ¯ 0.5 ç§’é–ƒçˆä¸€æ¬¡ï¼Œç„¡é™å¾ªç’° */
    }

    .alarm-card {
      background: #0f1620;
      border: 1px solid #1f2a36;
      border-radius: 14px;
      padding: 14px;
      width: 360px;
      /* å›ºå®šå¯¬åº¦ä»¥åˆ©æ©«å‘æ’åˆ— */
      box-shadow: 0 8px 22px rgba(0, 0, 0, 0.28);
    }

    .alarm-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 8px;
    }

    .title {
      font-weight: 700;
      font-size: 16px;
    }

    /* æ§åˆ¶é … */
    input[type=number] {
      width: 80px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #2a394a;
      background: #0b1119;
      color: #cfe4ff;
    }

    input[type=file] {
      flex: 1;
    }

    input[type=range] {
      width: 220px;
      accent-color: #5aa3ff;
    }

    .note {
      width: 150px;
      height: 56px;
      resize: vertical;
      border-radius: 8px;
      padding: 6px;
      background: #0b1119;
      color: #cfe4ff;
      border: 1px solid #2a394a;
    }

    /* æŒ‰éˆ• */
    button {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #284158;
      background: #132131;
      color: #dff0ff;
      cursor: pointer;
      transition: transform .05s ease-in-out, background .15s;
    }

    button:hover {
      background: #182a3d;
    }

    button:active {
      transform: translateY(1px);
    }

    /* é¡å¤–å€å¡Š */
    .options {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed #2a394a;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .wave-row label {
      margin-right: 8px;
    }

    .tts-label {
      margin-right: 8px;
    }

    .info {
      margin-top: 8px;
      font-size: 14px;
      color: #c7d5e5;
    }

    .log-area {
      margin-top: 10px;
      border-radius: 10px;
      border: 1px dashed #2a394a;
      background: #0b1119;
      padding: 8px;
      height: 110px;
      overflow: auto;
      font-size: 13px;
    }

    code {
      color: #8ad;
    }
  </style>
</head>

<body>
  <div class="topbar container">
    <h1>å¤šå€‹å®šæ™‚é¬§é˜</h1>
    <div class="row">
      <label for="alarmCount">é¬§é˜æ•¸é‡ï¼š</label>
      <input type="number" id="alarmCount" min="1" max="24" value="2" />
      <span class="hint">ï¼ˆè¼¸å…¥æ•¸å­—å¾Œæœƒè‡ªå‹•ç”¢ç”Ÿå€å¡Šï¼›æ¯å€‹å€å¡Šå¯å„è‡ªè¨­å®šéŸ³æª”èˆ‡å€’æ•¸æ™‚é–“ï¼‰</span>
    </div>
  </div>

  <div id="alarmsContainer" class="alarms-container"></div>

  <!-- å®Œæ•´çš„ UI çµæ§‹éƒ½æ”¾åœ¨ templateï¼ŒJS åª clone ä¸å‹•æ…‹å»º DOM -->
  <template id="alarmTemplate">
    <div class="alarm-card" data-id="">
      <div class="alarm-head">
        <div class="title">é¬§é˜ #<span class="alarm-index"></span></div>
        <textarea class="note" placeholder="å‚™è¨»ï¼ˆèªéŸ³æœƒè®€é€™è£¡çš„å…§å®¹ï¼‰"></textarea>
      </div>

      <div class="row">
        <label>éŸ³æ•ˆï¼ˆMP3ï¼‰ï¼š</label>
        <input type="file" class="audio-file" accept="audio/*" />
        <small class="hint">æœªé¸æª”æ™‚æœƒå„ªå…ˆæ’­æ”¾ <code>test-beep.mp3</code>ï¼›æ‰¾ä¸åˆ°å‰‡ç”¨å…§å»ºèœ‚é³´æˆ–èªéŸ³ã€‚</small>
      </div>

      <div class="row">
        <label>å€’æ•¸æ™‚é–“ï¼š</label>
        <input type="number" class="mins" min="0" value="0" /> åˆ†
        <input type="number" class="secs" min="0" max="59" value="5" /> ç§’
      </div>

      <div class="row gap">
        <button class="start-btn">é–‹å§‹å€’æ•¸</button>
        <button class="stop-btn">çµæŸå€’æ•¸</button>
      </div>

      <div class="info">
        <div>æŒ‰ä¸‹æ™‚é–“ï¼š<span class="start-at">â€”</span></div>
        <div>è§¸ç™¼æ™‚é–“ï¼š<span class="target-at">â€”</span></div>
        <div class="status">è·é›¢ <span class="target-at-inline">â€”</span> é‚„æœ‰ <span class="remain">â€”</span></div>
      </div>

      <!-- è‡ªè¨‚æé†’å€ï¼ˆå…¨éƒ¨ä»¥ HTML è¡¨é”ï¼›JS åƒ…è®€å€¼èˆ‡ç¶å®šäº‹ä»¶ï¼‰ -->
      <div class="options">
        <div class="row wave-row">
          <label>èœ‚é³´æ³¢å½¢ï¼š</label>
          <label><input type="radio" class="wave-radio" data-group="wave" value="sine">sine</label>
          <label><input type="radio" class="wave-radio" data-group="wave" value="square" checked>square</label>
          <label><input type="radio" class="wave-radio" data-group="wave" value="sawtooth">sawtooth</label>
          <label><input type="radio" class="wave-radio" data-group="wave" value="triangle">triangle</label>
        </div>

        <div class="row">
          <label>éŸ³é«˜(Hz)ï¼š</label>
          <input type="range" class="freq-range" min="300" max="3000" step="1" value="1200" />
          <span class="freq-val">1200</span>
        </div>
        <div class="row">
          <label>æ¯è²é•·åº¦(ms)ï¼š</label>
          <input type="range" class="len-range" min="20" max="400" step="5" value="90" />
          <span class="len-val">90</span>
        </div>
        <div class="row">
          <label>é–“éš”(ms)ï¼š</label>
          <input type="range" class="gap-range" min="0" max="200" step="5" value="60" />
          <span class="gap-val">60</span>
        </div>
        <div class="row">
          <label>éŸ³é‡(%)ï¼š</label>
          <input type="range" class="vol-range" min="5" max="100" step="1" value="50" />
          <span class="vol-val">28%</span>
        </div>
        <div class="row">
          <label>æ¬¡æ•¸(1~5)ï¼š</label>
          <input type="range" class="times-range" min="1" max="5" step="1" value="2" />
          <span class="times-val">2</span>
        </div>

        <div class="row">
          <label class="tts-label"><input type="checkbox" class="tts-toggle" checked /> ä½¿ç”¨èªéŸ³æé†’ï¼ˆè®€å‚™è¨»ï¼‰</label>
          <button class="preview-tts-btn">è©¦è½èªéŸ³</button>
          <button class="preview-beep-btn">è©¦è½å…§å»ºèœ‚é³´</button>
        </div>
      </div>

      <div class="log-area"></div>
      <audio class="audio" preload="auto" style="display:none;"></audio>
    </div>
  </template>

  <script>
    // å¤šå€‹å®šæ™‚é¬§é˜ï¼ˆå¾ªç’° + è‡ªè¨‚èœ‚é³´/èªéŸ³ + localStorageï¼‰
    // è·è²¬ï¼šåƒ…è™•ç†è¡Œç‚ºèˆ‡è³‡æ–™ï¼›HTML çµæ§‹åœ¨ index.html çš„ <template> ä¸­ï¼›å¤–è§€åœ¨ style.cssã€‚

    const alarmsContainer = document.getElementById('alarmsContainer');
    const alarmCountInput = document.getElementById('alarmCount');
    const template = document.getElementById('alarmTemplate');

    /** æ¯å€‹é¬§é˜çš„å…§éƒ¨ç‹€æ…‹ */
    const state = new Map(); // id -> { timeoutId, intervalId, target, periodMs, objectUrl, running, runId }
    let nextId = 1;

    /* ===================== localStorage Helpers ===================== */
    const LS_COUNT_KEY = 'alarm:count';
    const lsKey = (id, prop) => `alarm:${id}:${prop}`;
    const ls = {
      getNum(key, defVal) {
        const v = localStorage.getItem(key);
        const n = Number(v);
        return Number.isFinite(n) ? n : defVal;
      },
      getStr(key, defVal) {
        const v = localStorage.getItem(key);
        return v == null ? defVal : v;
      },
      set(key, val) { localStorage.setItem(key, String(val)); },
    };

    /* ===================== å°å·¥å…· ===================== */
    function pad2(n) { return n.toString().padStart(2, '0'); }
    function mmss(ms) {
      if (ms < 0) ms = 0;
      const sec = Math.floor(ms / 1000);
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${pad2(m)}:${pad2(s)}`;
    }

    /** è®“ç‹€æ…‹è¡Œç¶­æŒå›ºå®šéª¨æ¶ï¼ˆé¿å…ç”¨ textContent æŠŠ span æ¸…æ‰ï¼‰ */
    function setStatusLine(card, labelText) {
      const statusEl = card.querySelector('.status');
      if (!statusEl) return;
      statusEl.innerHTML = `${labelText}ï½œè·é›¢ <span class="target-at-inline">â€”</span> é‚„æœ‰ <span class="remain">â€”</span>`;
    }

    /* ===================== Web Audio: å…§å»ºèœ‚é³´ ===================== */
    let audioCtx = null;
    function ensureAudioCtx() {
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AC();
      }
      if (audioCtx.state === 'suspended') audioCtx.resume();
      return audioCtx;
    }

    /**
     * ä¾è¨­å®šæ’­æ”¾å—¶è²ï¼ˆ1~5 è²ï¼‰ã€‚ä¸è‡ªå‹•é™ç¸®ç¸½æ™‚é•·ã€‚
     * @param {number} ms  å–®è²åç›®é•·åº¦ï¼ˆæ¯«ç§’ï¼‰ï¼ŒUI æœƒé™åˆ¶ â‰¤ 400
     * @param {number} freq ç¬¬ä¸€è²é »ç‡ï¼ˆHzï¼‰
     * @param {object} opts { wave, gapMs, volume, times, freq2Delta, attack, release }
     */
    async function webBeep(ms = 90, freq = 1200, opts = {}) {
      const ctx = ensureAudioCtx();

      let times = Math.max(1, Math.min(5, opts.times ?? 2));
      let gapSec = Math.max(0, (opts.gapMs ?? 60) / 1000);
      const wave = opts.wave ?? 'square';
      const volume = Math.max(0.01, Math.min(0.6, opts.volume ?? 0.28));
      const f1 = freq;
      const f2Delta = opts.freq2Delta ?? 300;
      const attack = Math.max(0.001, opts.attack ?? 0.003);
      const release = Math.max(0.01, opts.release ?? 0.025);

      let beepSec = Math.max(0.02, Math.min(0.4, ms / 1000));
      const hold = Math.max(0, beepSec - attack - release);
      const startAt = ctx.currentTime + 0.01;

      function scheduleOneBeep(t0, hz) {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = wave;
        osc.frequency.setValueAtTime(hz, t0);

        gain.gain.setValueAtTime(0.0001, t0);
        gain.gain.exponentialRampToValueAtTime(volume, t0 + attack);
        gain.gain.setValueAtTime(volume, t0 + attack + hold);
        gain.gain.exponentialRampToValueAtTime(0.0001, t0 + attack + hold + release);

        osc.connect(gain).connect(ctx.destination);
        osc.start(t0);
        osc.stop(t0 + attack + hold + release);
        osc.onended = () => { try { osc.disconnect(); gain.disconnect(); } catch (_) { } };
      }

      for (let i = 0; i < times; i++) {
        const t = startAt + i * (beepSec + (i === 0 ? 0 : gapSec));
        const hz = i === 0 ? f1 : f1 + f2Delta;
        scheduleOneBeep(t, hz);
      }

      const totalSec = times * beepSec + (times - 1) * gapSec;
      return new Promise(res => setTimeout(res, totalSec * 1000));
    }

    /* ===================== Web Speech: èªéŸ³æé†’ï¼ˆè®€å‚™è¨»ï¼‰ ===================== */

    function canUseTTS() {
      return 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
    }

    function waitForVoices() {
      return new Promise((res) => {
        const has = speechSynthesis.getVoices();
        if (has && has.length) return res();
        const timer = setTimeout(res, 600);
        const onV = () => { clearTimeout(timer); speechSynthesis.removeEventListener('voiceschanged', onV); res(); };
        speechSynthesis.addEventListener('voiceschanged', onV);
      });
    }

    function pickVoice(langPref) {
      const voices = speechSynthesis.getVoices() || [];
      if (!voices.length) return null;
      const lang = (langPref || navigator.language || 'zh-TW').toLowerCase();
      const exact = voices.find(v => v.lang && v.lang.toLowerCase().startsWith(lang));
      const zhAny = voices.find(v => v.lang && v.lang.toLowerCase().startsWith('zh'));
      return exact || zhAny || voices[0];
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

    async function speakOnce(text, { rate = 1, pitch = 1, volume = 1, lang } = {}) {
      await waitForVoices();
      return new Promise((resolve) => {
        try {
          const u = new SpeechSynthesisUtterance(text);
          const v = pickVoice(lang);
          if (v) u.voice = v;
          u.rate = rate;
          u.pitch = pitch;
          u.volume = Math.max(0, Math.min(1, volume));
          u.onend = () => resolve();
          u.onerror = () => resolve(); // ä¸é˜»å¡å€’æ•¸
          speechSynthesis.cancel();    // é¿å…é‡ç–Š
          speechSynthesis.speak(u);
        } catch (_) { resolve(); }
      });
    }

    /** è®€å‡ºå‚™è¨»ï¼ˆç©ºç™½å‰‡è®€ã€Œæ™‚é–“åˆ°äº†ã€ï¼‰ï¼Œå¯é‡è¤‡ times æ¬¡ï¼Œé–“éš” gapMs */
    async function speakNote(card, times, gapMs, volumePct = 100) {
      if (!canUseTTS()) throw new Error('TTS not supported');
      const note = card.querySelector('textarea.note')?.value?.trim() || '';
      const msg = note ? `${note}ï¼Œæ™‚é–“åˆ°äº†ã€‚` : 'æ™‚é–“åˆ°äº†ã€‚';
      const vol = Math.max(0, Math.min(1, (volumePct || 100) / 100));
      for (let i = 0; i < times; i++) {
        await speakOnce(msg, { rate: 1, pitch: 1, volume: vol, lang: 'zh-TW' });
        if (i < times - 1) await sleep(Math.max(0, gapMs || 0));
      }
    }

    /* ===================== UI å»ºç«‹ï¼ˆclone templateï¼‰ ===================== */

    function createAlarmCard(withId = null) {
      const id = withId ?? nextId++;
      const frag = template.content.cloneNode(true);
      const card = frag.querySelector('.alarm-card');
      card.dataset.id = String(id);
      card.querySelector('.alarm-index').textContent = String(id);

      // ç¢ºä¿æ¯å¼µå¡ç‰‡çš„æ³¢å½¢ radio ä¸äº’æ¶ï¼ˆä¾ id è¨­å®š nameï¼‰
      for (const r of card.querySelectorAll('input.wave-radio[data-group="wave"]')) {
        r.setAttribute('name', `wave-${id}`);
      }

      alarmsContainer.appendChild(frag);

      // åˆå§‹åŒ–ç‹€æ…‹å®¹å™¨ï¼ˆå« runIdï¼‰
      state.set(id, {
        timeoutId: null,
        intervalId: null,
        target: null,
        periodMs: null,
        objectUrl: null,
        running: false,
        runId: 0,
      });

      // é‚„åŸæ­¤å¡ç‰‡è¨­å®š
      restoreCardSettings(id, findCard(id));
    }

    function destroyAlarmCard(card) {
      const id = Number(card.dataset.id);
      stopAlarm(id);
      state.delete(id);
      card.remove();
    }

    function findCard(id) {
      return alarmsContainer.querySelector(`.alarm-card[data-id="${id}"]`);
    }

    /* ===================== äº‹ä»¶å§”æ´¾ ===================== */

    function saveCountToLS() {
      const want = Math.max(1, Math.min(24, Number(alarmCountInput.value || 1)));
      ls.set(LS_COUNT_KEY, want);
    }

    alarmsContainer.addEventListener('input', (ev) => {
      const card = ev.target.closest('.alarm-card');
      if (!card) return;
      const id = Number(card.dataset.id);

      // å‚™è¨»
      if (ev.target.matches('textarea.note')) {
        ls.set(lsKey(id, 'note'), ev.target.value);
      }

      // rangeï¼šfreq/len/gap/vol/times
      if (ev.target.matches('.freq-range, .len-range, .gap-range, .vol-range, .times-range')) {
        const map = [
          ['freq-range', 'freq', ''],
          ['len-range', 'len', ''],
          ['gap-range', 'gap', ''],
          ['vol-range', 'vol', '%'],
          ['times-range', 'times', '']
        ];
        for (const [cls, prop, suffix] of map) {
          if (ev.target.classList.contains(cls)) {
            let val = Number(ev.target.value);
            if (prop === 'len') val = Math.max(20, Math.min(400, val)); // æ¯è² â‰¤ 400ms
            if (prop === 'times') val = Math.max(1, Math.min(5, val));    // æ¬¡æ•¸ 1~5
            ls.set(lsKey(id, prop), val);
            const span = card.querySelector(`.${prop}-val`);
            if (span) span.textContent = suffix ? `${val}${suffix}` : String(val);
          }
        }
      }

      // å€’æ•¸åˆ†ç§’ï¼šå³æ™‚ä¿å­˜èˆ‡æ ¡æ­£
      if (ev.target.matches('.mins, .secs')) {
        const minsEl = card.querySelector('.mins');
        const secsEl = card.querySelector('.secs');
        let mins = parseInt(minsEl.value, 10);
        let secs = parseInt(secsEl.value, 10);
        if (!Number.isFinite(mins) || mins < 0) mins = 0;
        if (!Number.isFinite(secs) || secs < 0) secs = 0;
        if (secs > 59) secs = 59;
        minsEl.value = String(mins);
        secsEl.value = String(secs);
        ls.set(lsKey(id, 'mins'), mins);
        ls.set(lsKey(id, 'secs'), secs);
      }

      // èªéŸ³é–‹é—œï¼ˆcheckbox ä¹Ÿæœƒè§¸ç™¼ inputï¼‰
      if (ev.target.matches('.tts-toggle')) {
        ls.set(lsKey(id, 'tts'), ev.target.checked ? 1 : 0);
      }
    });

    alarmsContainer.addEventListener('change', (ev) => {
      const card = ev.target.closest('.alarm-card');
      if (!card) return;
      const id = Number(card.dataset.id);

      // æ³¢å½¢ radio
      if (ev.target.matches('.wave-radio')) {
        const wave = card.querySelector(`input[name="wave-${id}"]:checked`)?.value ?? 'square';
        ls.set(lsKey(id, 'wave'), wave);
      }
    });

    alarmsContainer.addEventListener('click', async (ev) => {
      const btn = ev.target.closest('button');
      if (!btn) return;
      const card = ev.target.closest('.alarm-card');
      if (!card) return;
      const id = Number(card.dataset.id);

      if (btn.classList.contains('preview-beep-btn')) {
        try { ensureAudioCtx(); } catch (_) { }
        const s = readBeepSettings(card, id);
        await webBeep(s.len, s.freq, {
          wave: s.wave, gapMs: s.gap, volume: s.vol / 100,
          times: s.times, freq2Delta: 300,
        });
        return;
      }

      if (btn.classList.contains('preview-tts-btn')) {
        if (!canUseTTS()) { alert('æ­¤ç€è¦½å™¨ä¸æ”¯æ´èªéŸ³åˆæˆ'); return; }
        const s = readBeepSettings(card, id);
        await speakNote(card, s.times, s.gap, s.vol);
        return;
      }

      if (btn.classList.contains('start-btn')) {
        try { ensureAudioCtx(); } catch (_) { }
        handleStart(id);
      } else if (btn.classList.contains('stop-btn')) {
        stopAlarm(id);
      }
    });

    /* ===================== è®€å¯«å¡ç‰‡è¨­å®š ===================== */

    function restoreCardSettings(id, card) {
      // ç‹€æ…‹åˆ—éª¨æ¶å…ˆå»ºå¥½ï¼Œé¿å…è¢«æ¸…ç©º span
      setStatusLine(card, 'å°±ç·’');

      // å‚™è¨»
      const noteVal = ls.getStr(lsKey(id, 'note'), '');
      card.querySelector('textarea.note').value = noteVal;

      // æ³¢å½¢
      const savedWave = ls.getStr(lsKey(id, 'wave'), 'square');
      const radio = card.querySelector(`input[name="wave-${id}"][value="${savedWave}"]`);
      if (radio) radio.checked = true;

      // æ‹–æ‹‰æ¢ + æ¬¡æ•¸
      const freq = ls.getNum(lsKey(id, 'freq'), 1200);
      const len = Math.max(20, Math.min(400, ls.getNum(lsKey(id, 'len'), 90)));
      const gap = Math.max(0, ls.getNum(lsKey(id, 'gap'), 60));
      const vol = ls.getNum(lsKey(id, 'vol'), 50);
      const times = Math.max(1, Math.min(5, ls.getNum(lsKey(id, 'times'), 2)));

      const set = (cls, val, fmt) => {
        const inp = card.querySelector(`.${cls}-range`);
        const sp = card.querySelector(`.${cls}-val`);
        if (inp) inp.value = String(val);
        if (sp) sp.textContent = fmt ? fmt(val) : (cls === 'vol' ? `${val}%` : String(val));
      };
      set('freq', freq);
      set('len', len);
      set('gap', gap);
      set('vol', vol, v => `${v}%`);
      set('times', times);

      // å€’æ•¸åˆ†ç§’ï¼ˆé è¨­ 0 åˆ† 5 ç§’ï¼‰
      const mins = Math.max(0, ls.getNum(lsKey(id, 'mins'), 0));
      const secs = Math.max(0, Math.min(59, ls.getNum(lsKey(id, 'secs'), 5)));
      card.querySelector('.mins').value = String(mins);
      card.querySelector('.secs').value = String(secs);

      // èªéŸ³é–‹é—œ
      const tts = ls.getNum(lsKey(id, 'tts'), 0) === 1;
      card.querySelector('.tts-toggle').checked = tts;
    }

    function readBeepSettings(card, id) {
      const wave = card.querySelector(`input[name="wave-${id}"]:checked`)?.value ?? 'square';
      const freq = Number(card.querySelector('.freq-range')?.value ?? 1200);
      const len = Math.max(20, Math.min(400, Number(card.querySelector('.len-range')?.value ?? 90)));
      const gap = Math.max(0, Number(card.querySelector('.gap-range')?.value ?? 60));
      const vol = Number(card.querySelector('.vol-range')?.value ?? 28);
      const times = Math.max(1, Math.min(5, Number(card.querySelector('.times-range')?.value ?? 2)));
      const tts = card.querySelector('.tts-toggle')?.checked ?? false;
      return { wave, freq, len, gap, vol, times, tts };
    }

    /* ===================== å€’æ•¸æ ¸å¿ƒï¼ˆrunId é˜²èˆŠå›å‘¼ï¼‰ ===================== */

    function clearTimers(id) {
      const st = state.get(id);
      if (!st) return;
      if (st.timeoutId) { clearTimeout(st.timeoutId); st.timeoutId = null; }
      if (st.intervalId) { clearInterval(st.intervalId); st.intervalId = null; }
    }

    function stopAlarm(id) {
      const st = state.get(id);
      if (!st) return;

      // ä½¿æ‰€æœ‰ä»åœ¨è·¯ä¸Šçš„å›å‘¼å¤±æ•ˆ
      st.runId++;
      st.running = false;
      clearTimers(id);

      // å–æ¶ˆèªéŸ³æ’­æ”¾éšŠåˆ—
      try { if (canUseTTS()) speechSynthesis.cancel(); } catch (_) { }

      const card = findCard(id);
      if (!card) return;

      // --- ç¢ºä¿æŒ‰åœæ­¢æ™‚ç«‹åˆ»çµæŸé–ƒçˆ ---
      card.classList.remove('is-blinking');

      // åœæ­¢éŸ³æ•ˆ
      const audio = card.querySelector('.audio');
      try { audio.pause(); audio.currentTime = 0; } catch (_) { }

      // é‡ç½®ç‹€æ…‹
      st.target = null;
      st.periodMs = null;

      // é‡å»ºç‹€æ…‹è¡Œéª¨æ¶ï¼ˆä¸è¦ç”¨ textContent æ¸…ç©ºï¼‰
      setStatusLine(card, 'å·²å–æ¶ˆå€’æ•¸');

      // å…¶ä»–æ¬„ä½æ­¸é›¶
      card.querySelector('.start-at').textContent = 'â€”';
      card.querySelector('.target-at').textContent = 'â€”';
      card.querySelector('.target-at-inline').textContent = 'â€”';
      card.querySelector('.remain').textContent = 'â€”';
    }

    function scheduleNextTrigger(id) {
      const st = state.get(id);
      if (!st || !st.running || !st.target || !st.periodMs) return;
      const card = findCard(id);
      if (!card) return;

      const myRun = st.runId; // æ•æ‰æœ¬è¼ª runId
      const audio = card.querySelector('.audio');
      const targetAtEl = card.querySelector('.target-at');
      const targetInline = card.querySelector('.target-at-inline');
      const log = card.querySelector('.log-area');

      const delay = Math.max(0, st.target.getTime() - Date.now());
      st.timeoutId = setTimeout(async () => {
        const cur = state.get(id);
        if (!cur || !cur.running || cur.runId !== myRun) return;

        // --- æ–°å¢ï¼šé–‹å§‹é–ƒçˆæé†’ ---
        card.classList.add('is-blinking');
        // å®‰å…¨æ©Ÿåˆ¶ï¼šè‹¥éŸ³æ•ˆæ’­æ”¾å‡ºéŒ¯ï¼Œ5ç§’å¾Œä¹Ÿå¼·åˆ¶åœæ­¢é–ƒçˆ
        const blinkProtector = setTimeout(() => card.classList.remove('is-blinking'), 5000);

        // ä¾å„ªå…ˆåºæ’­æ”¾ï¼šä¸Šå‚³éŸ³æª” -> èªéŸ³ï¼ˆè‹¥å•Ÿç”¨ï¼‰-> å…§å»ºèœ‚é³´
        let played = false;
        if (audio.src) {
          try {
            audio.currentTime = 0;
            await audio.play();
            played = true;
            // éŸ³æª”æ’­æ”¾å®Œç•¢å¾Œç§»é™¤é–ƒçˆï¼ˆè‹¥éŸ³æª”å¾ˆé•·ï¼Œæœƒä¾æ“šå…¶é•·åº¦æ±ºå®šï¼‰
            audio.onended = () => card.classList.remove('is-blinking');
          } catch (_) { played = false; }
        }

        if (!played) {
          const s = readBeepSettings(card, id);
          if (s.tts && canUseTTS()) {
            try {
              await speakNote(card, s.times, s.gap, s.vol);
              played = true;
            } catch (_) { }
          }
        }

        if (!played) {
          const s = readBeepSettings(card, id);
          try {
            await webBeep(s.len, s.freq, {
              wave: s.wave, gapMs: s.gap, volume: s.vol / 100,
              times: s.times, freq2Delta: 300
            });
          } catch (_) { }
        }

        // éŸ³æ•ˆ/èªéŸ³åŸ·è¡ŒçµæŸå¾Œï¼Œç§»é™¤é–ƒçˆä¸¦æ¸…é™¤å®‰å…¨è¨ˆæ™‚å™¨
        clearTimeout(blinkProtector);
        card.classList.remove('is-blinking');

        // è‹¥ä¸­é€”è¢«åœæ­¢ï¼ˆrunId è®Šäº†ï¼‰ï¼Œå°±ä¸è¦å†æ’ä¸‹ä¸€è¼ªæˆ–å¯« UI
        const cur2 = state.get(id);
        if (!cur2 || !cur2.running || cur2.runId !== myRun) return;

        // Log
        const div = document.createElement('div');
        div.textContent = `ğŸ”” è§¸ç™¼æ’­æ”¾ï¼š${new Date().toLocaleString()}`;
        log.appendChild(div);
        log.scrollTop = log.scrollHeight;

        // ä¸‹ä¸€è¼ªï¼ˆæŒçºŒå¾ªç’°ç›´åˆ°æ‰‹å‹•åœæ­¢ï¼‰
        cur2.target = new Date(cur2.target.getTime() + cur2.periodMs);
        if (targetAtEl) targetAtEl.textContent = cur2.target.toLocaleTimeString();
        if (targetInline) targetInline.textContent = cur2.target.toLocaleTimeString();

        scheduleNextTrigger(id);
      }, delay);
    }

    function handleStart(id) {
      const card = findCard(id);
      if (!card) return;

      // é–‹å§‹å‰æ¸…æ‰ä»»ä½•èªéŸ³ä½‡åˆ—ï¼ˆé¿å…ä¸Šä¸€è¼ªæ®˜ç•™ï¼‰
      try { if (canUseTTS()) speechSynthesis.cancel(); } catch (_) { }

      // è®€ & æ ¡æ­£ ä½¿ç”¨è€…è¼¸å…¥çš„åˆ†/ç§’
      const minsEl = card.querySelector('.mins');
      const secsEl = card.querySelector('.secs');
      let mins = parseInt(minsEl.value, 10);
      let secs = parseInt(secsEl.value, 10);
      if (!Number.isFinite(mins) || mins < 0) mins = 0;
      if (!Number.isFinite(secs) || secs < 0) secs = 0;
      if (secs > 59) secs = 59;

      // å›å¯« + ä¿å­˜åˆ° LS
      minsEl.value = String(mins);
      secsEl.value = String(secs);
      ls.set(lsKey(id, 'mins'), mins);
      ls.set(lsKey(id, 'secs'), secs);

      const total = (mins * 60 + secs) * 1000;
      if (!Number.isFinite(total) || total <= 0) {
        alert('è«‹è¼¸å…¥å¤§æ–¼ 0 çš„å€’æ•¸æ™‚é–“ï¼');
        return;
      }

      const st = state.get(id);
      if (!st) return;

      // ä½¿ä¸Šä¸€è¼ªå›å‘¼å¤±æ•ˆ & æ¸…èˆŠè¨ˆæ™‚å™¨
      st.runId++;
      clearTimers(id);

      // è¨­å®šéŸ³æ•ˆä¾†æº
      const input = card.querySelector('.audio-file');
      const audio = card.querySelector('.audio');
      try { audio.pause(); audio.currentTime = 0; } catch (_) { }
      if (input.files && input.files[0]) {
        if (st.objectUrl) { try { URL.revokeObjectURL(st.objectUrl); } catch (_) { } }
        st.objectUrl = URL.createObjectURL(input.files[0]);
        audio.src = st.objectUrl;
      } else if (st.objectUrl) {
        audio.src = st.objectUrl;
      } else {
        audio.src = 'test-beep.mp3'; // è‹¥ä¸å­˜åœ¨ï¼ŒscheduleNextTrigger æœƒè‡ªå‹• fallback
      }

      // è¨˜éŒ„æ™‚é–“
      const now = new Date();
      st.running = true;
      st.periodMs = total;
      st.target = new Date(now.getTime() + total);

      // ç‹€æ…‹åˆ—éª¨æ¶ + åˆå§‹å€¼
      setStatusLine(card, 'å€’æ•¸ä¸­ï¼ˆå¾ªç’°ï¼‰');
      card.querySelector('.start-at').textContent = now.toLocaleTimeString();
      card.querySelector('.target-at').textContent = st.target.toLocaleTimeString();
      card.querySelector('.target-at-inline').textContent = st.target.toLocaleTimeString();
      card.querySelector('.remain').textContent = mmss(total);

      // UI å€’æ•¸é¡¯ç¤º
      st.intervalId = setInterval(() => {
        const cur = state.get(id);
        if (!cur || !cur.running || !cur.target) return;
        const diff = cur.target.getTime() - Date.now();
        const remainEl = card.querySelector('.remain');
        if (remainEl) remainEl.textContent = mmss(diff);
      }, 200);

      // å®‰æ’ç¬¬ä¸€å€‹è§¸ç™¼
      scheduleNextTrigger(id);
    }

    /* ===================== å¡ç‰‡æ•¸é‡ç¶­è­· ===================== */
    function reconcileCards() {
      const want = Math.max(1, Math.min(24, Number(alarmCountInput.value || 1)));
      const current = alarmsContainer.querySelectorAll('.alarm-card').length;
      if (current < want) {
        for (let i = current + 1; i <= want; i++) createAlarmCard(i);
      } else if (current > want) {
        const cards = Array.from(alarmsContainer.querySelectorAll('.alarm-card'));
        for (let i = cards.length - 1; i >= want; i--) destroyAlarmCard(cards[i]);
      }
      ls.set(LS_COUNT_KEY, want);
    }

    /* ===================== åˆå§‹åŒ– ===================== */
    const savedCount = ls.getNum(LS_COUNT_KEY, Number(alarmCountInput.value || 2));
    alarmCountInput.value = Math.max(1, Math.min(24, savedCount));
    reconcileCards();

    alarmCountInput.addEventListener('input', () => {
      reconcileCards();
      saveCountToLS();
    });

  </script>
</body>

</html>